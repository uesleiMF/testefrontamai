{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nimport { matchPattern } from './PatternUtils';\nfunction deepEqual(a, b) {\n  if (a == b) return true;\n  if (a == null || b == null) return false;\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return deepEqual(item, b[index]);\n    });\n  }\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {\n    for (var p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue;\n      }\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false;\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false;\n      } else if (!deepEqual(a[p], b[p])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return String(a) === String(b);\n}\n\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = '/' + currentPathname;\n  }\n\n  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/';\n  }\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/';\n  }\n  return currentPathname === pathname;\n}\n\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\nfunction routeIsActive(pathname, routes, params) {\n  var remainingPathname = pathname,\n    paramNames = [],\n    paramValues = [];\n\n  // for...of would work here but it's probably slower post-transpilation.\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    var route = routes[i];\n    var pattern = route.path || '';\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname;\n      paramNames = [];\n      paramValues = [];\n    }\n    if (remainingPathname !== null && pattern) {\n      var matched = matchPattern(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every(function (paramName, index) {\n          return String(paramValues[index]) === String(params[paramName]);\n        });\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null) return query == null;\n  if (query == null) return true;\n  return deepEqual(query, activeQuery);\n}\n\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\nexport default function isActive(_ref, indexOnly, currentLocation, routes, params) {\n  var pathname = _ref.pathname,\n    query = _ref.query;\n  if (currentLocation == null) return false;\n\n  // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname;\n  }\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false;\n    }\n  }\n  return queryIsActive(query, currentLocation.query);\n}","map":{"version":3,"names":["_typeof","Symbol","iterator","obj","constructor","prototype","matchPattern","deepEqual","a","b","Array","isArray","length","every","item","index","p","Object","hasOwnProperty","call","undefined","String","pathIsActive","pathname","currentPathname","charAt","routeIsActive","routes","params","remainingPathname","paramNames","paramValues","i","len","route","pattern","path","matched","concat","paramName","queryIsActive","query","activeQuery","isActive","_ref","indexOnly","currentLocation"],"sources":["/media/ueslei/8c30fe4f-7d20-4ae9-ab32-8dd7ef60dcdf/home/jumf/GitHub/testefrontamai/node_modules/react-router/es/isActive.js"],"sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nimport { matchPattern } from './PatternUtils';\n\nfunction deepEqual(a, b) {\n  if (a == b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return deepEqual(item, b[index]);\n    });\n  }\n\n  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {\n    for (var p in a) {\n      if (!Object.prototype.hasOwnProperty.call(a, p)) {\n        continue;\n      }\n\n      if (a[p] === undefined) {\n        if (b[p] !== undefined) {\n          return false;\n        }\n      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {\n        return false;\n      } else if (!deepEqual(a[p], b[p])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return String(a) === String(b);\n}\n\n/**\n * Returns true if the current pathname matches the supplied one, net of\n * leading and trailing slash normalization. This is sufficient for an\n * indexOnly route match.\n */\nfunction pathIsActive(pathname, currentPathname) {\n  // Normalize leading slash for consistency. Leading slash on pathname has\n  // already been normalized in isActive. See caveat there.\n  if (currentPathname.charAt(0) !== '/') {\n    currentPathname = '/' + currentPathname;\n  }\n\n  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show\n  // `/foo` as active, but in this case, we would already have failed the\n  // match.\n  if (pathname.charAt(pathname.length - 1) !== '/') {\n    pathname += '/';\n  }\n  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {\n    currentPathname += '/';\n  }\n\n  return currentPathname === pathname;\n}\n\n/**\n * Returns true if the given pathname matches the active routes and params.\n */\nfunction routeIsActive(pathname, routes, params) {\n  var remainingPathname = pathname,\n      paramNames = [],\n      paramValues = [];\n\n  // for...of would work here but it's probably slower post-transpilation.\n  for (var i = 0, len = routes.length; i < len; ++i) {\n    var route = routes[i];\n    var pattern = route.path || '';\n\n    if (pattern.charAt(0) === '/') {\n      remainingPathname = pathname;\n      paramNames = [];\n      paramValues = [];\n    }\n\n    if (remainingPathname !== null && pattern) {\n      var matched = matchPattern(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n\n      if (remainingPathname === '') {\n        // We have an exact match on the route. Just check that all the params\n        // match.\n        // FIXME: This doesn't work on repeated params.\n        return paramNames.every(function (paramName, index) {\n          return String(paramValues[index]) === String(params[paramName]);\n        });\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns true if all key/value pairs in the given query are\n * currently active.\n */\nfunction queryIsActive(query, activeQuery) {\n  if (activeQuery == null) return query == null;\n\n  if (query == null) return true;\n\n  return deepEqual(query, activeQuery);\n}\n\n/**\n * Returns true if a <Link> to the given pathname/query combination is\n * currently active.\n */\nexport default function isActive(_ref, indexOnly, currentLocation, routes, params) {\n  var pathname = _ref.pathname,\n      query = _ref.query;\n\n  if (currentLocation == null) return false;\n\n  // TODO: This is a bit ugly. It keeps around support for treating pathnames\n  // without preceding slashes as absolute paths, but possibly also works\n  // around the same quirks with basenames as in matchRoutes.\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname;\n  }\n\n  if (!pathIsActive(pathname, currentLocation.pathname)) {\n    // The path check is necessary and sufficient for indexOnly, but otherwise\n    // we still need to check the routes.\n    if (indexOnly || !routeIsActive(pathname, routes, params)) {\n      return false;\n    }\n  }\n\n  return queryIsActive(query, currentLocation.query);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}