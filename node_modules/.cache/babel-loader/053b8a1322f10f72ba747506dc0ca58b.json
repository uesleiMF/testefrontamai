{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nvar loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {\n  var currentTurn = 0,\n    isDone = false;\n  var isSync = false,\n    hasNext = false,\n    doneArgs = void 0;\n  var done = function done() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    isDone = true;\n    if (isSync) {\n      // Iterate instead of recursing if possible.\n      doneArgs = args;\n      return;\n    }\n    callback.apply(undefined, args);\n  };\n  var next = function next() {\n    if (isDone) return;\n    hasNext = true;\n    if (isSync) return; // Iterate instead of recursing if possible.\n\n    isSync = true;\n    while (!isDone && currentTurn < turns && hasNext) {\n      hasNext = false;\n      work(currentTurn++, next, done);\n    }\n    isSync = false;\n    if (isDone) {\n      // This means the loop finished synchronously.\n      callback.apply(undefined, doneArgs);\n      return;\n    }\n    if (currentTurn >= turns && hasNext) {\n      isDone = true;\n      callback();\n    }\n  };\n  next();\n};","map":{"version":3,"names":["exports","__esModule","loopAsync","turns","work","callback","currentTurn","isDone","isSync","hasNext","doneArgs","done","_len","arguments","length","args","Array","_key","apply","undefined","next"],"sources":["/media/ueslei/8c30fe4f-7d20-4ae9-ab32-8dd7ef60dcdf/home/jumf/GitHub/testefrontamai/node_modules/history/lib/AsyncUtils.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nvar loopAsync = exports.loopAsync = function loopAsync(turns, work, callback) {\n  var currentTurn = 0,\n      isDone = false;\n  var isSync = false,\n      hasNext = false,\n      doneArgs = void 0;\n\n  var done = function done() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    isDone = true;\n\n    if (isSync) {\n      // Iterate instead of recursing if possible.\n      doneArgs = args;\n      return;\n    }\n\n    callback.apply(undefined, args);\n  };\n\n  var next = function next() {\n    if (isDone) return;\n\n    hasNext = true;\n\n    if (isSync) return; // Iterate instead of recursing if possible.\n\n    isSync = true;\n\n    while (!isDone && currentTurn < turns && hasNext) {\n      hasNext = false;\n      work(currentTurn++, next, done);\n    }\n\n    isSync = false;\n\n    if (isDone) {\n      // This means the loop finished synchronously.\n      callback.apply(undefined, doneArgs);\n      return;\n    }\n\n    if (currentTurn >= turns && hasNext) {\n      isDone = true;\n      callback();\n    }\n  };\n\n  next();\n};"],"mappings":"AAAA,YAAY;;AAEZA,OAAO,CAACC,UAAU,GAAG,IAAI;AACzB,IAAIC,SAAS,GAAGF,OAAO,CAACE,SAAS,GAAG,SAASA,SAAS,CAACC,KAAK,EAAEC,IAAI,EAAEC,QAAQ,EAAE;EAC5E,IAAIC,WAAW,GAAG,CAAC;IACfC,MAAM,GAAG,KAAK;EAClB,IAAIC,MAAM,GAAG,KAAK;IACdC,OAAO,GAAG,KAAK;IACfC,QAAQ,GAAG,KAAK,CAAC;EAErB,IAAIC,IAAI,GAAG,SAASA,IAAI,GAAG;IACzB,KAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAAM,EAAEC,IAAI,GAAGC,KAAK,CAACJ,IAAI,CAAC,EAAEK,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGL,IAAI,EAAEK,IAAI,EAAE,EAAE;MACnFF,IAAI,CAACE,IAAI,CAAC,GAAGJ,SAAS,CAACI,IAAI,CAAC;IAC9B;IAEAV,MAAM,GAAG,IAAI;IAEb,IAAIC,MAAM,EAAE;MACV;MACAE,QAAQ,GAAGK,IAAI;MACf;IACF;IAEAV,QAAQ,CAACa,KAAK,CAACC,SAAS,EAAEJ,IAAI,CAAC;EACjC,CAAC;EAED,IAAIK,IAAI,GAAG,SAASA,IAAI,GAAG;IACzB,IAAIb,MAAM,EAAE;IAEZE,OAAO,GAAG,IAAI;IAEd,IAAID,MAAM,EAAE,OAAO,CAAC;;IAEpBA,MAAM,GAAG,IAAI;IAEb,OAAO,CAACD,MAAM,IAAID,WAAW,GAAGH,KAAK,IAAIM,OAAO,EAAE;MAChDA,OAAO,GAAG,KAAK;MACfL,IAAI,CAACE,WAAW,EAAE,EAAEc,IAAI,EAAET,IAAI,CAAC;IACjC;IAEAH,MAAM,GAAG,KAAK;IAEd,IAAID,MAAM,EAAE;MACV;MACAF,QAAQ,CAACa,KAAK,CAACC,SAAS,EAAET,QAAQ,CAAC;MACnC;IACF;IAEA,IAAIJ,WAAW,IAAIH,KAAK,IAAIM,OAAO,EAAE;MACnCF,MAAM,GAAG,IAAI;MACbF,QAAQ,EAAE;IACZ;EACF,CAAC;EAEDe,IAAI,EAAE;AACR,CAAC"},"metadata":{},"sourceType":"script"}