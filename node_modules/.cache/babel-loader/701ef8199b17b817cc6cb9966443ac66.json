{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nimport warning from './routerWarning';\nimport computeChangedRoutes from './computeChangedRoutes';\nimport getTransitionUtils from './TransitionUtils';\nimport _isActive from './isActive';\nimport getComponents from './getComponents';\nimport matchRoutes from './matchRoutes';\nfunction hasAnyProperties(object) {\n  for (var p in object) {\n    if (Object.prototype.hasOwnProperty.call(object, p)) return true;\n  }\n  return false;\n}\nexport default function createTransitionManager(history, routes) {\n  var state = {};\n  var _getTransitionUtils = getTransitionUtils(),\n    runEnterHooks = _getTransitionUtils.runEnterHooks,\n    runChangeHooks = _getTransitionUtils.runChangeHooks,\n    runLeaveHooks = _getTransitionUtils.runLeaveHooks;\n\n  // Signature should be (location, indexOnly), but needs to support (path,\n  // query, indexOnly)\n\n  function isActive(location, indexOnly) {\n    location = history.createLocation(location);\n    return _isActive(location, indexOnly, state.location, state.routes, state.params);\n  }\n  var partialNextState = void 0;\n  function match(location, callback) {\n    if (partialNextState && partialNextState.location === location) {\n      // Continue from where we left off.\n      finishMatch(partialNextState, callback);\n    } else {\n      matchRoutes(routes, location, function (error, nextState) {\n        if (error) {\n          callback(error);\n        } else if (nextState) {\n          finishMatch(_extends({}, nextState, {\n            location: location\n          }), callback);\n        } else {\n          callback();\n        }\n      });\n    }\n  }\n  function finishMatch(nextState, callback) {\n    var _computeChangedRoutes = computeChangedRoutes(state, nextState),\n      leaveRoutes = _computeChangedRoutes.leaveRoutes,\n      changeRoutes = _computeChangedRoutes.changeRoutes,\n      enterRoutes = _computeChangedRoutes.enterRoutes;\n    runLeaveHooks(leaveRoutes, state);\n\n    // Tear down confirmation hooks for left routes\n    leaveRoutes.filter(function (route) {\n      return enterRoutes.indexOf(route) === -1;\n    }).forEach(removeListenBeforeHooksForRoute);\n\n    // change and enter hooks are run in series\n    runChangeHooks(changeRoutes, state, nextState, function (error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);\n      runEnterHooks(enterRoutes, nextState, finishEnterHooks);\n    });\n    function finishEnterHooks(error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);\n\n      // TODO: Fetch components after state is updated.\n      getComponents(nextState, function (error, components) {\n        if (error) {\n          callback(error);\n        } else {\n          // TODO: Make match a pure function and have some other API\n          // for \"match and update state\".\n          callback(null, null, state = _extends({}, nextState, {\n            components: components\n          }));\n        }\n      });\n    }\n    function handleErrorOrRedirect(error, redirectInfo) {\n      if (error) callback(error);else callback(null, redirectInfo);\n    }\n  }\n  var RouteGuid = 1;\n  function getRouteID(route) {\n    var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return route.__id__ || create && (route.__id__ = RouteGuid++);\n  }\n  var RouteHooks = Object.create(null);\n  function getRouteHooksForRoutes(routes) {\n    return routes.map(function (route) {\n      return RouteHooks[getRouteID(route)];\n    }).filter(function (hook) {\n      return hook;\n    });\n  }\n  function transitionHook(location, callback) {\n    matchRoutes(routes, location, function (error, nextState) {\n      if (nextState == null) {\n        // TODO: We didn't actually match anything, but hang\n        // onto error/nextState so we don't have to matchRoutes\n        // again in the listen callback.\n        callback();\n        return;\n      }\n\n      // Cache some state here so we don't have to\n      // matchRoutes() again in the listen callback.\n      partialNextState = _extends({}, nextState, {\n        location: location\n      });\n      var hooks = getRouteHooksForRoutes(computeChangedRoutes(state, partialNextState).leaveRoutes);\n      var result = void 0;\n      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {\n        // Passing the location arg here indicates to\n        // the user that this is a transition hook.\n        result = hooks[i](location);\n      }\n      callback(result);\n    });\n  }\n\n  /* istanbul ignore next: untestable with Karma */\n  function beforeUnloadHook() {\n    // Synchronously check to see if any route hooks want\n    // to prevent the current window/tab from closing.\n    if (state.routes) {\n      var hooks = getRouteHooksForRoutes(state.routes);\n      var message = void 0;\n      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {\n        // Passing no args indicates to the user that this is a\n        // beforeunload hook. We don't know the next location.\n        message = hooks[i]();\n      }\n      return message;\n    }\n  }\n  var unlistenBefore = void 0,\n    unlistenBeforeUnload = void 0;\n  function removeListenBeforeHooksForRoute(route) {\n    var routeID = getRouteID(route);\n    if (!routeID) {\n      return;\n    }\n    delete RouteHooks[routeID];\n    if (!hasAnyProperties(RouteHooks)) {\n      // teardown transition & beforeunload hooks\n      if (unlistenBefore) {\n        unlistenBefore();\n        unlistenBefore = null;\n      }\n      if (unlistenBeforeUnload) {\n        unlistenBeforeUnload();\n        unlistenBeforeUnload = null;\n      }\n    }\n  }\n\n  /**\n   * Registers the given hook function to run before leaving the given route.\n   *\n   * During a normal transition, the hook function receives the next location\n   * as its only argument and can return either a prompt message (string) to show the user,\n   * to make sure they want to leave the page; or `false`, to prevent the transition.\n   * Any other return value will have no effect.\n   *\n   * During the beforeunload event (in browsers) the hook receives no arguments.\n   * In this case it must return a prompt message to prevent the transition.\n   *\n   * Returns a function that may be used to unbind the listener.\n   */\n  function listenBeforeLeavingRoute(route, hook) {\n    var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);\n    var routeID = getRouteID(route, true);\n    RouteHooks[routeID] = hook;\n    if (thereWereNoRouteHooks) {\n      // setup transition & beforeunload hooks\n      unlistenBefore = history.listenBefore(transitionHook);\n      if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);\n    }\n    return function () {\n      removeListenBeforeHooksForRoute(route);\n    };\n  }\n\n  /**\n   * This is the API for stateful environments. As the location\n   * changes, we update state and call the listener. We can also\n   * gracefully handle errors and redirects.\n   */\n  function listen(listener) {\n    function historyListener(location) {\n      if (state.location === location) {\n        listener(null, state);\n      } else {\n        match(location, function (error, redirectLocation, nextState) {\n          if (error) {\n            listener(error);\n          } else if (redirectLocation) {\n            history.replace(redirectLocation);\n          } else if (nextState) {\n            listener(null, nextState);\n          } else {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Location \"%s\" did not match any routes', location.pathname + location.search + location.hash) : void 0;\n          }\n        });\n      }\n    }\n\n    // TODO: Only use a single history listener. Otherwise we'll end up with\n    // multiple concurrent calls to match.\n\n    // Set up the history listener first in case the initial match redirects.\n    var unsubscribe = history.listen(historyListener);\n    if (state.location) {\n      // Picking up on a matchContext.\n      listener(null, state);\n    } else {\n      historyListener(history.getCurrentLocation());\n    }\n    return unsubscribe;\n  }\n  return {\n    isActive: isActive,\n    match: match,\n    listenBeforeLeavingRoute: listenBeforeLeavingRoute,\n    listen: listen\n  };\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","warning","computeChangedRoutes","getTransitionUtils","_isActive","getComponents","matchRoutes","hasAnyProperties","object","p","createTransitionManager","history","routes","state","_getTransitionUtils","runEnterHooks","runChangeHooks","runLeaveHooks","isActive","location","indexOnly","createLocation","params","partialNextState","match","callback","finishMatch","error","nextState","_computeChangedRoutes","leaveRoutes","changeRoutes","enterRoutes","filter","route","indexOf","forEach","removeListenBeforeHooksForRoute","redirectInfo","handleErrorOrRedirect","finishEnterHooks","components","RouteGuid","getRouteID","create","undefined","__id__","RouteHooks","getRouteHooksForRoutes","map","hook","transitionHook","hooks","result","len","beforeUnloadHook","message","unlistenBefore","unlistenBeforeUnload","routeID","listenBeforeLeavingRoute","thereWereNoRouteHooks","listenBefore","listenBeforeUnload","listen","listener","historyListener","redirectLocation","replace","process","env","NODE_ENV","pathname","search","hash","unsubscribe","getCurrentLocation"],"sources":["/media/ueslei/8c30fe4f-7d20-4ae9-ab32-8dd7ef60dcdf/home/jumf/GitHub/testefrontamai/node_modules/react-router/es/createTransitionManager.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from './routerWarning';\nimport computeChangedRoutes from './computeChangedRoutes';\nimport getTransitionUtils from './TransitionUtils';\nimport _isActive from './isActive';\nimport getComponents from './getComponents';\nimport matchRoutes from './matchRoutes';\n\nfunction hasAnyProperties(object) {\n  for (var p in object) {\n    if (Object.prototype.hasOwnProperty.call(object, p)) return true;\n  }return false;\n}\n\nexport default function createTransitionManager(history, routes) {\n  var state = {};\n\n  var _getTransitionUtils = getTransitionUtils(),\n      runEnterHooks = _getTransitionUtils.runEnterHooks,\n      runChangeHooks = _getTransitionUtils.runChangeHooks,\n      runLeaveHooks = _getTransitionUtils.runLeaveHooks;\n\n  // Signature should be (location, indexOnly), but needs to support (path,\n  // query, indexOnly)\n\n\n  function isActive(location, indexOnly) {\n    location = history.createLocation(location);\n\n    return _isActive(location, indexOnly, state.location, state.routes, state.params);\n  }\n\n  var partialNextState = void 0;\n\n  function match(location, callback) {\n    if (partialNextState && partialNextState.location === location) {\n      // Continue from where we left off.\n      finishMatch(partialNextState, callback);\n    } else {\n      matchRoutes(routes, location, function (error, nextState) {\n        if (error) {\n          callback(error);\n        } else if (nextState) {\n          finishMatch(_extends({}, nextState, { location: location }), callback);\n        } else {\n          callback();\n        }\n      });\n    }\n  }\n\n  function finishMatch(nextState, callback) {\n    var _computeChangedRoutes = computeChangedRoutes(state, nextState),\n        leaveRoutes = _computeChangedRoutes.leaveRoutes,\n        changeRoutes = _computeChangedRoutes.changeRoutes,\n        enterRoutes = _computeChangedRoutes.enterRoutes;\n\n    runLeaveHooks(leaveRoutes, state);\n\n    // Tear down confirmation hooks for left routes\n    leaveRoutes.filter(function (route) {\n      return enterRoutes.indexOf(route) === -1;\n    }).forEach(removeListenBeforeHooksForRoute);\n\n    // change and enter hooks are run in series\n    runChangeHooks(changeRoutes, state, nextState, function (error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);\n\n      runEnterHooks(enterRoutes, nextState, finishEnterHooks);\n    });\n\n    function finishEnterHooks(error, redirectInfo) {\n      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);\n\n      // TODO: Fetch components after state is updated.\n      getComponents(nextState, function (error, components) {\n        if (error) {\n          callback(error);\n        } else {\n          // TODO: Make match a pure function and have some other API\n          // for \"match and update state\".\n          callback(null, null, state = _extends({}, nextState, { components: components }));\n        }\n      });\n    }\n\n    function handleErrorOrRedirect(error, redirectInfo) {\n      if (error) callback(error);else callback(null, redirectInfo);\n    }\n  }\n\n  var RouteGuid = 1;\n\n  function getRouteID(route) {\n    var create = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    return route.__id__ || create && (route.__id__ = RouteGuid++);\n  }\n\n  var RouteHooks = Object.create(null);\n\n  function getRouteHooksForRoutes(routes) {\n    return routes.map(function (route) {\n      return RouteHooks[getRouteID(route)];\n    }).filter(function (hook) {\n      return hook;\n    });\n  }\n\n  function transitionHook(location, callback) {\n    matchRoutes(routes, location, function (error, nextState) {\n      if (nextState == null) {\n        // TODO: We didn't actually match anything, but hang\n        // onto error/nextState so we don't have to matchRoutes\n        // again in the listen callback.\n        callback();\n        return;\n      }\n\n      // Cache some state here so we don't have to\n      // matchRoutes() again in the listen callback.\n      partialNextState = _extends({}, nextState, { location: location });\n\n      var hooks = getRouteHooksForRoutes(computeChangedRoutes(state, partialNextState).leaveRoutes);\n\n      var result = void 0;\n      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {\n        // Passing the location arg here indicates to\n        // the user that this is a transition hook.\n        result = hooks[i](location);\n      }\n\n      callback(result);\n    });\n  }\n\n  /* istanbul ignore next: untestable with Karma */\n  function beforeUnloadHook() {\n    // Synchronously check to see if any route hooks want\n    // to prevent the current window/tab from closing.\n    if (state.routes) {\n      var hooks = getRouteHooksForRoutes(state.routes);\n\n      var message = void 0;\n      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {\n        // Passing no args indicates to the user that this is a\n        // beforeunload hook. We don't know the next location.\n        message = hooks[i]();\n      }\n\n      return message;\n    }\n  }\n\n  var unlistenBefore = void 0,\n      unlistenBeforeUnload = void 0;\n\n  function removeListenBeforeHooksForRoute(route) {\n    var routeID = getRouteID(route);\n    if (!routeID) {\n      return;\n    }\n\n    delete RouteHooks[routeID];\n\n    if (!hasAnyProperties(RouteHooks)) {\n      // teardown transition & beforeunload hooks\n      if (unlistenBefore) {\n        unlistenBefore();\n        unlistenBefore = null;\n      }\n\n      if (unlistenBeforeUnload) {\n        unlistenBeforeUnload();\n        unlistenBeforeUnload = null;\n      }\n    }\n  }\n\n  /**\n   * Registers the given hook function to run before leaving the given route.\n   *\n   * During a normal transition, the hook function receives the next location\n   * as its only argument and can return either a prompt message (string) to show the user,\n   * to make sure they want to leave the page; or `false`, to prevent the transition.\n   * Any other return value will have no effect.\n   *\n   * During the beforeunload event (in browsers) the hook receives no arguments.\n   * In this case it must return a prompt message to prevent the transition.\n   *\n   * Returns a function that may be used to unbind the listener.\n   */\n  function listenBeforeLeavingRoute(route, hook) {\n    var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);\n    var routeID = getRouteID(route, true);\n\n    RouteHooks[routeID] = hook;\n\n    if (thereWereNoRouteHooks) {\n      // setup transition & beforeunload hooks\n      unlistenBefore = history.listenBefore(transitionHook);\n\n      if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);\n    }\n\n    return function () {\n      removeListenBeforeHooksForRoute(route);\n    };\n  }\n\n  /**\n   * This is the API for stateful environments. As the location\n   * changes, we update state and call the listener. We can also\n   * gracefully handle errors and redirects.\n   */\n  function listen(listener) {\n    function historyListener(location) {\n      if (state.location === location) {\n        listener(null, state);\n      } else {\n        match(location, function (error, redirectLocation, nextState) {\n          if (error) {\n            listener(error);\n          } else if (redirectLocation) {\n            history.replace(redirectLocation);\n          } else if (nextState) {\n            listener(null, nextState);\n          } else {\n            process.env.NODE_ENV !== 'production' ? warning(false, 'Location \"%s\" did not match any routes', location.pathname + location.search + location.hash) : void 0;\n          }\n        });\n      }\n    }\n\n    // TODO: Only use a single history listener. Otherwise we'll end up with\n    // multiple concurrent calls to match.\n\n    // Set up the history listener first in case the initial match redirects.\n    var unsubscribe = history.listen(historyListener);\n\n    if (state.location) {\n      // Picking up on a matchContext.\n      listener(null, state);\n    } else {\n      historyListener(history.getCurrentLocation());\n    }\n\n    return unsubscribe;\n  }\n\n  return {\n    isActive: isActive,\n    match: match,\n    listenBeforeLeavingRoute: listenBeforeLeavingRoute,\n    listen: listen\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}