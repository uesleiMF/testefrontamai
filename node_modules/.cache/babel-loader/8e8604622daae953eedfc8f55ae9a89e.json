{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nimport { loopAsync } from './AsyncUtils';\nimport { isPromise } from './PromiseUtils';\nimport { matchPattern } from './PatternUtils';\nimport warning from './routerWarning';\nimport { createRoutes } from './RouteUtils';\nfunction getChildRoutes(route, location, paramNames, paramValues, callback) {\n  if (route.childRoutes) {\n    return [null, route.childRoutes];\n  }\n  if (!route.getChildRoutes) {\n    return [];\n  }\n  var sync = true,\n    result = void 0;\n  var partialNextState = {\n    location: location,\n    params: createParams(paramNames, paramValues)\n  };\n  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {\n    childRoutes = !error && createRoutes(childRoutes);\n    if (sync) {\n      result = [error, childRoutes];\n      return;\n    }\n    callback(error, childRoutes);\n  });\n  if (isPromise(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {\n    return callback(null, createRoutes(childRoutes));\n  }, callback);\n  sync = false;\n  return result; // Might be undefined.\n}\n\nfunction getIndexRoute(route, location, paramNames, paramValues, callback) {\n  if (route.indexRoute) {\n    callback(null, route.indexRoute);\n  } else if (route.getIndexRoute) {\n    var partialNextState = {\n      location: location,\n      params: createParams(paramNames, paramValues)\n    };\n    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {\n      callback(error, !error && createRoutes(indexRoute)[0]);\n    });\n    if (isPromise(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {\n      return callback(null, createRoutes(indexRoute)[0]);\n    }, callback);\n  } else if (route.childRoutes || route.getChildRoutes) {\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n        return;\n      }\n      var pathless = childRoutes.filter(function (childRoute) {\n        return !childRoute.path;\n      });\n      loopAsync(pathless.length, function (index, next, done) {\n        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {\n          if (error || indexRoute) {\n            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);\n            done(error, routes);\n          } else {\n            next();\n          }\n        });\n      }, function (err, routes) {\n        callback(null, routes);\n      });\n    };\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\nfunction assignParams(params, paramNames, paramValues) {\n  return paramNames.reduce(function (params, paramName, index) {\n    var paramValue = paramValues && paramValues[index];\n    if (Array.isArray(params[paramName])) {\n      params[paramName].push(paramValue);\n    } else if (paramName in params) {\n      params[paramName] = [params[paramName], paramValue];\n    } else {\n      params[paramName] = paramValue;\n    }\n    return params;\n  }, params);\n}\nfunction createParams(paramNames, paramValues) {\n  return assignParams({}, paramNames, paramValues);\n}\nfunction matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {\n  var pattern = route.path || '';\n  if (pattern.charAt(0) === '/') {\n    remainingPathname = location.pathname;\n    paramNames = [];\n    paramValues = [];\n  }\n\n  // Only try to match the path if the route actually has a pattern, and if\n  // we're not just searching for potential nested absolute paths.\n  if (remainingPathname !== null && pattern) {\n    try {\n      var matched = matchPattern(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n    } catch (error) {\n      callback(error);\n    }\n\n    // By assumption, pattern is non-empty here, which is the prerequisite for\n    // actually terminating a match.\n    if (remainingPathname === '') {\n      var match = {\n        routes: [route],\n        params: createParams(paramNames, paramValues)\n      };\n      getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {\n        if (error) {\n          callback(error);\n        } else {\n          if (Array.isArray(indexRoute)) {\n            var _match$routes;\n            process.env.NODE_ENV !== 'production' ? warning(indexRoute.every(function (route) {\n              return !route.path;\n            }), 'Index routes should not have paths') : void 0;\n            (_match$routes = match.routes).push.apply(_match$routes, indexRoute);\n          } else if (indexRoute) {\n            process.env.NODE_ENV !== 'production' ? warning(!indexRoute.path, 'Index routes should not have paths') : void 0;\n            match.routes.push(indexRoute);\n          }\n          callback(null, match);\n        }\n      });\n      return;\n    }\n  }\n  if (remainingPathname != null || route.childRoutes) {\n    // Either a) this route matched at least some of the path or b)\n    // we don't have to load this route's children asynchronously. In\n    // either case continue checking for matches in the subtree.\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n      } else if (childRoutes) {\n        // Check the child routes to see if any of them match.\n        matchRoutes(childRoutes, location, function (error, match) {\n          if (error) {\n            callback(error);\n          } else if (match) {\n            // A child route matched! Augment the match and pass it up the stack.\n            match.routes.unshift(route);\n            callback(null, match);\n          } else {\n            callback();\n          }\n        }, remainingPathname, paramNames, paramValues);\n      } else {\n        callback();\n      }\n    };\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\n/**\n * Asynchronously matches the given location to a set of routes and calls\n * callback(error, state) when finished. The state object will have the\n * following properties:\n *\n * - routes       An array of routes that matched, in hierarchical order\n * - params       An object of URL parameters\n *\n * Note: This operation may finish synchronously if no routes have an\n * asynchronous getChildRoutes method.\n */\nexport default function matchRoutes(routes, location, callback, remainingPathname) {\n  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n  if (remainingPathname === undefined) {\n    // TODO: This is a little bit ugly, but it works around a quirk in history\n    // that strips the leading slash from pathnames when using basenames with\n    // trailing slashes.\n    if (location.pathname.charAt(0) !== '/') {\n      location = _extends({}, location, {\n        pathname: '/' + location.pathname\n      });\n    }\n    remainingPathname = location.pathname;\n  }\n  loopAsync(routes.length, function (index, next, done) {\n    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {\n      if (error || match) {\n        done(error, match);\n      } else {\n        next();\n      }\n    });\n  }, callback);\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","loopAsync","isPromise","matchPattern","warning","createRoutes","getChildRoutes","route","location","paramNames","paramValues","callback","childRoutes","sync","result","partialNextState","params","createParams","childRoutesReturn","error","then","getIndexRoute","indexRoute","indexRoutesReturn","onChildRoutes","pathless","filter","childRoute","path","index","next","done","routes","concat","Array","isArray","err","apply","undefined","assignParams","reduce","paramName","paramValue","push","matchRouteDeep","remainingPathname","pattern","charAt","pathname","matched","match","_match$routes","process","env","NODE_ENV","every","matchRoutes","unshift"],"sources":["/media/ueslei/8c30fe4f-7d20-4ae9-ab32-8dd7ef60dcdf/home/jumf/GitHub/testefrontamai/node_modules/react-router/es/matchRoutes.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport { loopAsync } from './AsyncUtils';\nimport { isPromise } from './PromiseUtils';\nimport { matchPattern } from './PatternUtils';\nimport warning from './routerWarning';\nimport { createRoutes } from './RouteUtils';\n\nfunction getChildRoutes(route, location, paramNames, paramValues, callback) {\n  if (route.childRoutes) {\n    return [null, route.childRoutes];\n  }\n  if (!route.getChildRoutes) {\n    return [];\n  }\n\n  var sync = true,\n      result = void 0;\n\n  var partialNextState = {\n    location: location,\n    params: createParams(paramNames, paramValues)\n  };\n\n  var childRoutesReturn = route.getChildRoutes(partialNextState, function (error, childRoutes) {\n    childRoutes = !error && createRoutes(childRoutes);\n    if (sync) {\n      result = [error, childRoutes];\n      return;\n    }\n\n    callback(error, childRoutes);\n  });\n\n  if (isPromise(childRoutesReturn)) childRoutesReturn.then(function (childRoutes) {\n    return callback(null, createRoutes(childRoutes));\n  }, callback);\n\n  sync = false;\n  return result; // Might be undefined.\n}\n\nfunction getIndexRoute(route, location, paramNames, paramValues, callback) {\n  if (route.indexRoute) {\n    callback(null, route.indexRoute);\n  } else if (route.getIndexRoute) {\n    var partialNextState = {\n      location: location,\n      params: createParams(paramNames, paramValues)\n    };\n\n    var indexRoutesReturn = route.getIndexRoute(partialNextState, function (error, indexRoute) {\n      callback(error, !error && createRoutes(indexRoute)[0]);\n    });\n\n    if (isPromise(indexRoutesReturn)) indexRoutesReturn.then(function (indexRoute) {\n      return callback(null, createRoutes(indexRoute)[0]);\n    }, callback);\n  } else if (route.childRoutes || route.getChildRoutes) {\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n        return;\n      }\n\n      var pathless = childRoutes.filter(function (childRoute) {\n        return !childRoute.path;\n      });\n\n      loopAsync(pathless.length, function (index, next, done) {\n        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {\n          if (error || indexRoute) {\n            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);\n            done(error, routes);\n          } else {\n            next();\n          }\n        });\n      }, function (err, routes) {\n        callback(null, routes);\n      });\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\nfunction assignParams(params, paramNames, paramValues) {\n  return paramNames.reduce(function (params, paramName, index) {\n    var paramValue = paramValues && paramValues[index];\n\n    if (Array.isArray(params[paramName])) {\n      params[paramName].push(paramValue);\n    } else if (paramName in params) {\n      params[paramName] = [params[paramName], paramValue];\n    } else {\n      params[paramName] = paramValue;\n    }\n\n    return params;\n  }, params);\n}\n\nfunction createParams(paramNames, paramValues) {\n  return assignParams({}, paramNames, paramValues);\n}\n\nfunction matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {\n  var pattern = route.path || '';\n\n  if (pattern.charAt(0) === '/') {\n    remainingPathname = location.pathname;\n    paramNames = [];\n    paramValues = [];\n  }\n\n  // Only try to match the path if the route actually has a pattern, and if\n  // we're not just searching for potential nested absolute paths.\n  if (remainingPathname !== null && pattern) {\n    try {\n      var matched = matchPattern(pattern, remainingPathname);\n      if (matched) {\n        remainingPathname = matched.remainingPathname;\n        paramNames = [].concat(paramNames, matched.paramNames);\n        paramValues = [].concat(paramValues, matched.paramValues);\n      } else {\n        remainingPathname = null;\n      }\n    } catch (error) {\n      callback(error);\n    }\n\n    // By assumption, pattern is non-empty here, which is the prerequisite for\n    // actually terminating a match.\n    if (remainingPathname === '') {\n      var match = {\n        routes: [route],\n        params: createParams(paramNames, paramValues)\n      };\n\n      getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {\n        if (error) {\n          callback(error);\n        } else {\n          if (Array.isArray(indexRoute)) {\n            var _match$routes;\n\n            process.env.NODE_ENV !== 'production' ? warning(indexRoute.every(function (route) {\n              return !route.path;\n            }), 'Index routes should not have paths') : void 0;\n            (_match$routes = match.routes).push.apply(_match$routes, indexRoute);\n          } else if (indexRoute) {\n            process.env.NODE_ENV !== 'production' ? warning(!indexRoute.path, 'Index routes should not have paths') : void 0;\n            match.routes.push(indexRoute);\n          }\n\n          callback(null, match);\n        }\n      });\n\n      return;\n    }\n  }\n\n  if (remainingPathname != null || route.childRoutes) {\n    // Either a) this route matched at least some of the path or b)\n    // we don't have to load this route's children asynchronously. In\n    // either case continue checking for matches in the subtree.\n    var onChildRoutes = function onChildRoutes(error, childRoutes) {\n      if (error) {\n        callback(error);\n      } else if (childRoutes) {\n        // Check the child routes to see if any of them match.\n        matchRoutes(childRoutes, location, function (error, match) {\n          if (error) {\n            callback(error);\n          } else if (match) {\n            // A child route matched! Augment the match and pass it up the stack.\n            match.routes.unshift(route);\n            callback(null, match);\n          } else {\n            callback();\n          }\n        }, remainingPathname, paramNames, paramValues);\n      } else {\n        callback();\n      }\n    };\n\n    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);\n    if (result) {\n      onChildRoutes.apply(undefined, result);\n    }\n  } else {\n    callback();\n  }\n}\n\n/**\n * Asynchronously matches the given location to a set of routes and calls\n * callback(error, state) when finished. The state object will have the\n * following properties:\n *\n * - routes       An array of routes that matched, in hierarchical order\n * - params       An object of URL parameters\n *\n * Note: This operation may finish synchronously if no routes have an\n * asynchronous getChildRoutes method.\n */\nexport default function matchRoutes(routes, location, callback, remainingPathname) {\n  var paramNames = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var paramValues = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n\n  if (remainingPathname === undefined) {\n    // TODO: This is a little bit ugly, but it works around a quirk in history\n    // that strips the leading slash from pathnames when using basenames with\n    // trailing slashes.\n    if (location.pathname.charAt(0) !== '/') {\n      location = _extends({}, location, {\n        pathname: '/' + location.pathname\n      });\n    }\n    remainingPathname = location.pathname;\n  }\n\n  loopAsync(routes.length, function (index, next, done) {\n    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {\n      if (error || match) {\n        done(error, match);\n      } else {\n        next();\n      }\n    });\n  }, callback);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}